###### 优化器选择不使用索引的情况

说明： 有些时候，优化器没有利用索引去查找数据，而是通过全表扫描聚集索引查找。多发于范围查找和JOIN连接操作。

**情况1**：数据量很大的范围查找

当查找范围很大，并且通过辅助索引查找的内容不能覆盖最终的结果时。虽然辅助索引查到的数据是连续的，但是还需要对聚集索引进行二次查找，第二次的查找就是离散的，如果查找范围很大的话，与其多次查找，不如一次全表扫描。

###### MySQL的优化机制

1. MMR(Multi-Range Read)优化

   MMR优化的目的是为了减少磁盘的**随机访问**，将随机访问尽可能的转为较为顺序的访问。在查询辅助索引时，如果还需要查聚集索引，就将查询结果按主键排序，然后再去查聚集索引。

2. ICP(Index Condition Pushdown)优化

   以前的MySQL是先通过索引查找记录，然后再由where子句优化。现在是在通过索引查找记录时就先根据where子句过滤，最后再去读磁盘中的数据。

###### 自适应哈希索引

MySQL中哈希索引时数据自身创建使用的，DBA不能进行干预，适合单一查询，不支持模糊或者范围查找，这也是hash的特点。

##### 全文索引

普通的索引支持的模糊查询只是前缀查询，不支持关键字查询。全文索引是专门用于全文检索的索引类型。

全文检索：将存储于数据库中的整本书或者整篇文章中的任意内容信息查找出来的技术。主要是利用倒排索引。

倒排索引

>1. inverted file index: {单词，单词所在的文档id}
>2. full inverted index: {单词，(单词所在文档的id，在文档中的具体位置)}
>
>InnoDB采用的第二种方式。

InnoDB通过两个结构实现的全文检索

>1. 辅助表(Auxiliary Table): 这个表就是上面所说的倒排索引表，为了提高全文检索的并行性能，有6张这样的表。存于磁盘中
>2. FTS Index Cache(全文检索索引缓存)：顾名思义这就是上面那个表在内存中的缓存。红黑树结构

修改首先是在缓存中完成中，然后再批量写回到辅助表中。

限制：一张表只能建一个全文索引，不支持没有界定符的语言(因为需要分词)，如中文、日语、韩语，对多列建全文索引的话，必须使用同样的字符集和排序规则。

###### 前缀索引

说明：对索引字段的前N个字符创建索引。需要保证索引有较高的选择性。

缺点

>1. 覆盖索引就失效了，很明显，因为不得不再查聚集索引
>
>2. 排序分组ORDER BY和GROUP BY操作时不能使用

###### 什么情况下索引会失效？

1. 索引时发生了隐式类型转换。

2. 用Where条件中含有OR，但是并不是涉及的每一列都有索引，比如 SELECT * FROM TABLE WHERE

   A='XXX' OR B='XXX'。因为OR两边的都要查找，因为B没有索引，所以不得不全表搜索，利用索引查A没有意义，不如全表搜索时把A,B都查了。

3. 对于联合索引，没有前导列不会使用索引，因为联合索引的单一表项是局部有序的。
4. 如果引擎认为全表扫描更快时就不用索引。
5. 非前缀索引的模糊索引"%xxx%"，不会使用索引，除非有全文索引。