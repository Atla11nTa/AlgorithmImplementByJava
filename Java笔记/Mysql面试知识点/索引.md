## 索引

###### 索引分类

>按数据结构分类
>
>1. B+树索引
>2. hash索引
>3. 全文索引(使用了红黑树结构)
>
>按功能分类
>
>1. 聚集索引
>2. 辅助索引(二级索引)
>3. 全文索引
>4. 自适应哈希索引

###### 聚集索引

InnoDB存储引擎是索引组织表, 表中数据都是按照主键顺序存放的. 为何呢? 因为聚集索引就是按照每张表的主键构造B+树, 与普通索引不同的是聚集索引的叶子节点存放了实际的行数据, 所以聚集索引的叶节点也叫数据页. 所以索引组织表中数据也索引的一部分.

因为实际的数据只能按一棵B+树的顺序存放, 这也确定了聚集索引的唯一性. 

注意: 

1. 聚集索引是唯一的, 但并不一定通过主键构造, 毕竟主键可能未定义,  若主键定义了, 聚集索引就根据主键建立. 如果主键未定义, 那么该表第一个唯一非空索引就被作为聚集索引；索引没有主键也没有合适的唯一索引, 那么innodb内部就会生成一个隐藏的自增主键用作聚集索引.
2. 聚集索引的存储只是逻辑上连续, 物理上并不一定连续.

3. 每个叶节点可能有多行数据(这也是B+树的特点)

优势: 聚集索引上存储了真实的数据, 所以与主键有关的范围查询/查询/排序, 速度会非常快.

###### 辅助索引(二级索引)

特点: 叶子节点不存放每行数据的全部数据, 只存放两个, key: 自己索引的键值, value: 主键的键值, 通过主键的键值利用聚集索引二次查找, 这也是为什么叫做二级索引的原因. 

显而易见, 辅助索引并不影响数据的组织, 所以辅助索引可以多个.

###### 关于Cardinality

关于索引的唯一值数量的估计值, 反映索引对应字段的选择性. 说估计值是因为Cardinality并不是实时更新的, 不是更次更新索引就会更新这个值, ANALYZE TABLE会强制更新. 

Cardinality意义: 如果这个值比数据库行数小太多, 说明这个索引有很多重复值, 引擎在做查询时就不会利用这个索引. 所以为了索引更好的工作, 应该在闲时更新这个值.  另一方面, 为了发挥索引的优势, 应该在那些不容易出现重复值的列上建索引, 盲目建并不好. 

innodb的自动更新: 当表中1/16的数据发生变化时更新, 或者进行20亿次更新操作时更新该值.

###### 联合索引

概念: 联合索引就是依靠多列建立的索引.

特征: 联合索引的B+树中, 是按照第一列升序排列的, 如果第一列相同, 第一列相同的这些元素中第二列就是升序, 如果第二列相同,那么第三列就是升序的. 以此类推....

举例说明:

1. 假设以a,b两列建立一个索引, 执行语句 SELECT * FROM TABLE WHERE a = xxx and b = xxx.

   这是会利用索引的, 因为第一列a列是有序, 查找了之后检查连续的a值, 与目标相等的b即可, 因为b是局部有序的.

2. 假设以a,b两列建立一个索引, 执行语句 SELECT * FROM TABLE WHERE b = xxx

   这是不会利用索引的, 因为全局来看, b是无序的.

3. 假设这里有两个索引, key(a,b)的联合索引和key(a), 那么SELECT * FROM TABLE WHERE a = xxx时, 会使用哪一个索引呢?

   答案是按照key(a)进行索引, 因为mysql叶节点大小是有限制的, 那么key(a)的B+树每个节点存放的信息肯定更多, 理论上通过key(a)进行索引速度更快.

4. 假设以a,b,c三列建立一个索引, 执行语句 SELECT * FROM TABLE WHERE a= xxx ORDER BY c 

   这个就不会使用索引, 答案和第二个问题差不多, 因为仅当a,b都确定时, c才局部有序, 才会利用索引.

总结

>1. 联合索引的前n列确定时, n+1列就是局部有序的
>2. 通过联合索引局部有序的特点, 当前n列确定时, 有关n+1列的排序操作就可以利用上索引.

###### 覆盖索引

概念: 若仅查辅助索引就能得到结果, 就不查聚集索引了.

举例说明:

1. SELECT COUNT(*) FROM  TABLE

   若这个表上有辅助索引,  那么就不会通过聚集索引进行统计, 这是显而易见的, 因为辅助索引的B+树节点包含的信息多, IO次数会少一些.

   

