## 索引

###### 索引分类

>按数据结构分类
>
>1. B+树索引
>2. hash索引
>3. 全文索引(使用了红黑树结构)
>
>按功能分类
>
>1. 聚集索引
>2. 辅助索引(二级索引)
>3. 全文索引
>4. 自适应哈希索引

###### 聚集索引

InnoDB存储引擎是索引组织表, 表中数据都是按照主键顺序存放的. 为何呢? 因为聚集索引就是按照每张表的主键构造B+树, 与普通索引不同的是聚集索引的叶子节点存放了实际的行数据, 所以聚集索引的叶节点也叫数据页. 所以索引组织表中数据也索引的一部分.

因为实际的数据只能按一棵B+树的顺序存放, 这也确定了聚集索引的唯一性. 

注意: 

1. 聚集索引是唯一的, 但并不一定通过主键构造, 毕竟主键可能未定义,  若主键定义了, 聚集索引就根据主键建立. 如果主键未定义, 那么该表第一个唯一非空索引就被作为聚集索引；索引没有主键也没有合适的唯一索引, 那么innodb内部就会生成一个隐藏的自增主键用作聚集索引.
2. 聚集索引的存储只是逻辑上连续, 物理上并不一定连续.

3. 每个叶节点可能有多行数据(这也是B+树的特点)

优势: 聚集索引上存储了真实的数据, 所以与主键有关的范围查询/查询/排序, 速度会非常快.

###### 辅助索引(二级索引)

特点: 叶子节点不存放每行数据的全部数据, 只存放两个, key: 自己索引的键值, value: 主键的键值, 通过主键的键值利用聚集索引二次查找, 这也是为什么叫做二级索引的原因. 

显而易见, 辅助索引并不影响数据的组织, 所以辅助索引可以多个.

###### 关于Cardinality

关于索引的唯一值数量的估计值, 反映索引对应字段的选择性. 说估计值是因为Cardinality并不是实时更新的, 不是更次更新索引就会更新这个值, ANALYZE TABLE会强制更新. 

Cardinality意义: 如果这个值比数据库行数小太多, 说明这个索引有很多重复值, 引擎在做查询时就不会利用这个索引. 所以为了索引更好的工作, 应该在闲时更新这个值.  另一方面, 为了发挥索引的优势, 应该在那些不容易出现重复值的列上建索引, 盲目建并不好. 

innodb的自动更新: 当表中1/16的数据发生变化时更新, 或者进行20亿次更新操作时更新该值.

###### 联合索引

概念: 联合索引就是依靠多列建立的索引.

特征: 联合索引的B+树中, 是按照第一列升序排列的, 如果第一列相同, 第一列相同的这些元素中第二列就是升序, 如果第二列相同,那么第三列就是升序的. 以此类推....

举例说明:

1. 假设以a,b两列建立一个索引, 执行语句 SELECT * FROM TABLE WHERE a = xxx and b = xxx.

   这是会利用索引的, 因为第一列a列是有序, 查找了之后检查连续的a值, 与目标相等的b即可, 因为b是局部有序的.

2. 假设以a,b两列建立一个索引, 执行语句 SELECT * FROM TABLE WHERE b = xxx

   这是不会利用索引的, 因为全局来看, b是无序的.

3. 假设这里有两个索引, key(a,b)的联合索引和key(a), 那么SELECT * FROM TABLE WHERE a = xxx时, 会使用哪一个索引呢?

   答案是按照key(a)进行索引, 因为mysql叶节点大小是有限制的, 那么key(a)的B+树每个节点存放的信息肯定更多, 理论上通过key(a)进行索引速度更快.

4. 假设以a,b,c三列建立一个索引, 执行语句 SELECT * FROM TABLE WHERE a= xxx ORDER BY c 

   这个就不会使用索引, 答案和第二个问题差不多, 因为仅当a,b都确定时, c才局部有序, 才会利用索引.

总结

>1. 联合索引的前n列确定时, n+1列就是局部有序的
>2. 通过联合索引局部有序的特点, 当前n列确定时, 有关n+1列的排序操作就可以利用上索引.

###### 覆盖索引

概念: 若仅查辅助索引就能得到结果, 就不查聚集索引了.

举例说明:

1. SELECT COUNT(*) FROM  TABLE

   若这个表上有辅助索引,  那么就不会通过聚集索引进行统计, 这是显而易见的, 因为辅助索引的B+树节点包含的信息多, IO次数会少一些.

   
###### 优化器选择不使用索引的情况

说明： 有些时候，优化器没有利用索引去查找数据，而是通过全表扫描聚集索引查找。多发于范围查找和JOIN连接操作。

**情况1**：数据量很大的范围查找

当查找范围很大，并且通过辅助索引查找的内容不能覆盖最终的结果时。虽然辅助索引查到的数据是连续的，但是还需要对聚集索引进行二次查找，第二次的查找就是离散的，如果查找范围很大的话，与其多次查找，不如一次全表扫描。

###### MySQL的优化机制

1. MMR(Multi-Range Read)优化

   MMR优化的目的是为了减少磁盘的**随机访问**，将随机访问尽可能的转为较为顺序的访问。在查询辅助索引时，如果还需要查聚集索引，就将查询结果按主键排序，然后再去查聚集索引。

2. ICP(Index Condition Pushdown)优化

   以前的MySQL是先通过索引查找记录，然后再由where子句优化。现在是在通过索引查找记录时就先根据where子句过滤，最后再去读磁盘中的数据。

###### 自适应哈希索引

MySQL中哈希索引时数据自身创建使用的，DBA不能进行干预，适合单一查询，不支持模糊或者范围查找，这也是hash的特点。

##### 全文索引

普通的索引支持的模糊查询只是前缀查询，不支持关键字查询。全文索引是专门用于全文检索的索引类型。

全文检索：将存储于数据库中的整本书或者整篇文章中的任意内容信息查找出来的技术。主要是利用倒排索引。

倒排索引

>1. inverted file index: {单词，单词所在的文档id}
>2. full inverted index: {单词，(单词所在文档的id，在文档中的具体位置)}
>
>InnoDB采用的第二种方式。

InnoDB通过两个结构实现的全文检索

>1. 辅助表(Auxiliary Table): 这个表就是上面所说的倒排索引表，为了提高全文检索的并行性能，有6张这样的表。存于磁盘中
>2. FTS Index Cache(全文检索索引缓存)：顾名思义这就是上面那个表在内存中的缓存。红黑树结构

修改首先是在缓存中完成中，然后再批量写回到辅助表中。

限制：一张表只能建一个全文索引，不支持没有界定符的语言(因为需要分词)，如中文、日语、韩语，对多列建全文索引的话，必须使用同样的字符集和排序规则。

###### 前缀索引

说明：对索引字段的前N个字符创建索引。需要保证索引有较高的选择性。

缺点

>1. 覆盖索引就失效了，很明显，因为不得不再查聚集索引
>
>2. 排序分组ORDER BY和GROUP BY操作时不能使用

###### 什么情况下索引会失效？

1. 索引时发生了隐式类型转换。

2. 用Where条件中含有OR，但是并不是涉及的每一列都有索引，比如 SELECT * FROM TABLE WHERE

   A='XXX' OR B='XXX'。因为OR两边的都要查找，因为B没有索引，所以不得不全表搜索，利用索引查A没有意义，不如全表搜索时把A,B都查了。

3. 对于联合索引，没有前导列不会使用索引，因为联合索引的单一表项是局部有序的。
4. 如果引擎认为全表扫描更快时就不用索引。
5. 非前缀索引的模糊索引"%xxx%"，不会使用索引，除非有全文索引。
