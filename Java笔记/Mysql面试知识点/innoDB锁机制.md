## InnoDB锁机制

InnoDB锁分类

按各种分类：https://www.jianshu.com/p/102ad89152d9

>**共享锁(S锁)**： 允许事务读一行数据
>
>**排他锁(X锁)**：允许事务修改一行数据
>
>注意S锁和X锁都是行锁，除了S锁能与S锁兼容外，其他之间均不兼容。
>
>**多粒度锁定**：InnoDB规定这种锁定允许事务在行级和表级的锁同时存在，通过意向锁实现。
>
>**意向共享锁(IS)**：事务想获得一张表中某几行的共享锁。
>
>**意向排他锁(IX)**：事务想获得表中某几行的排他锁。
>
>InnoDB支持的是行级别的锁，因此意向锁不会阻塞除全表扫描外的任何请求。

###### 读的一致性解决方案

1. 一致性非锁定读（MVCC）

   ​		对于READ COMMITTED和REPEATABLE READ两个等级的读一致性问题，InnoDB通过多版本并发控制机制解决。通过这种机制，即使某行存在其他事务加的X锁，也不需要等待就可以得到结果。具体通过快照数据，快照数据实际是通过undo段完成的，而undo段是事务中用于回滚数据的，所以并无额外开销。

   | 封锁等级 | 无锁情况             | 有锁情况             |
   | :------- | -------------------- | -------------------- |
   | 读已提交 | 读最新的版本         | 读最新的快照         |
   | 可重复读 | 读本事务开始时的版本 | 读本事务开始时的版本 |

   解释原因：

   1. 读已提交：是为了解决读脏数据的问题，所以当发现读取的行存在X锁时，就读快照，这样的话，即使另一个事务撤销更改，就不会出现读取了未提交的数据。
   2. 可重复读：可重复读是为了解决事务进行过程中的两次读取，由于另一事务提交了修改，导致两次的读取结果不一致。通过MVCC机制，在可重复读隔离等级下，都是读的本次事务开始时的版本，其他事务的修改就不会影响到读取结果了。

2. 一致性锁定读

   ​		通过对读取操作显示的加锁，或者处于可串行化封锁等级下。

   显式加锁

   >加X锁：SELECT ... FOR UPDATE
   >
   >加S锁：SELECT ... LOCK IN SHARE MODE

###### 自增长与锁

​		对于自增长的列，有一种特殊的**表锁机制**，当执行插入操作时，就会对整个表加锁，但是不需要等整个事务结束，对自增长列插入完成就释放锁了，不过还是比较影响并发的性能。在更新的引擎中使用了一种轻量级互斥量实现自增长。

​		注意：自增长值的列必须是索引，同时必须是索引的第一列。

**外键和锁**

​		外键主要用于引用完整性的约束检查，InnoDB中会默认为外键列加锁，因为不然就会产生表级锁。

​		解释一下为什么外键没有索引就会产生表级锁？

​		主要是因为修改父表时，还要去检查子表的外键列，也进行修改，所以若没有索引，就需要对子表进行全表扫描，就需要加表级锁，这样的话就会很容易产生死锁。

###### 行级锁分类

​		说明： InnoDB默认情况是开启间隙锁(因为默认是可重复读隔离等级)，所说的行锁基本是间隙锁，特殊情况才会降级为单行锁。间隙锁解决幻读问题。

>Record Lock：单行锁
>
>Gap Lock: 间隙锁，锁定一个范围，但不包含记录本身
>
>Next-Key Lock: 上面两种的结合，锁定一个范围，而且会锁定记录本身。

举例说明Next-key Lock：

​		假设索引有10,11,13,20这几个值，那么锁住的区间就可能是：(-~, 10], (11,13], (13,20]. (20,-~)

​	**1. 何时可以将间隙锁降级为行锁？**

​		答：仅当查询的列是唯一索引（列中所有数据都不同），而且查找的给定值而不是范围查询的时候会降级为行锁，典型的比如聚集索引肯定是唯一索引，所以会降级。

​		比如现在有一列b数据分别是1,1,3,6,8，明显不是唯一索引，执行SELECT * WHERE b=3，那么就会加一个间隙锁，锁定范围是(1, 3]和(3, 6)，一个Next-Key Lock和Gap Lock。

 2. 如果关闭间隙锁？

    ​	答：事务的隔离等级修改为READ COMMITTED，或着修改参数。

###### 事务的隔离等级以及InnoDB的解决方案

| 隔离级别 | 解释                                   | InnoDB的解决方案          |
| -------- | -------------------------------------- | ------------------------- |
| 读未提交 | 无任何保护，产生脏读问题               |                           |
| 读已提交 | 解决脏读问题                           | MVCC                      |
| 可重复读 | 解决不可重复读问题                     | MVCC+间隙锁，并且解决幻读 |
| 可串行化 | 强制事务串行执行，不会出现任何并发错误 | 读取也会加锁              |

  1. **幻读和不可重复读的不同点？**

     答：幻读和不可重复读都是因为连续两次读取由于另一个事务修改并提交导致两次读取结果不一致。但是不可重复读指的是数据不一致，而幻读是结果集不一致，第二次读取返回之前不存在的行。幻读强调记录数不一致，所以要利用间隙锁锁住一个区间。

###### 死锁及解决方案

>**超时回滚：**如果一个事务等待超时，就回滚，这样的话，如果两个死锁的事务，由于一个的主动放弃，另一个就可以正常进行，死锁就解决了。
>
>**等待图：**构建一个事务之间的等待关系图，通过拓扑排序算法检测是否有环，若有环就让环中回滚消耗最小的事务回滚，这样就解决死锁问题了。